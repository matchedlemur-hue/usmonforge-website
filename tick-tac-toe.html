<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe (Human vs. CPU)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the game grid and modal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px; /* Gap between cells */
            width: 300px; /* Fixed size for the grid container */
            height: 300px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            border-radius: 12px;
            font-size: 48px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.15s, transform 0.1s;
        }

        .cell:hover:not(.x-player):not(.o-player) {
            background-color: #e0f2fe; /* Light blue on hover */
        }

        .cell.x-player {
            color: #ef4444; /* Red 500 (Human) */
        }

        .cell.o-player {
            color: #3b82f6; /* Blue 500 (CPU) */
        }

        /* Modal specific styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 100; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            backdrop-filter: blur(5px);
            padding-top: 50px;
        }

        .modal-content {
            background-color: #ffffff;
            margin: 15% auto; 
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            width: 90%; 
            max-width: 400px; 
            text-align: center;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .modal-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .modal-message {
            font-size: 18px;
            margin-bottom: 25px;
            color: #4b5563;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            .board {
                width: 90vw;
                height: 90vw;
            }
            .cell {
                font-size: 12vw;
            }
        }
    </style>
</head>
<body class="bg-gray-50">

    <div class="flex flex-col items-center p-4">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-2 tracking-tight">Tic-Tac-Toe</h1>
        <p class="text-sm text-gray-500 mb-6">Human (<span class="text-red-500 font-bold">X</span>) vs. CPU (<span class="text-blue-500 font-bold">O</span>)</p>

        <!-- Current Status Display -->
        <div id="status" class="text-xl font-semibold mb-6 p-3 rounded-lg bg-white shadow-md w-full max-w-sm text-center">
            <!-- Text updated by JavaScript -->
        </div>

        <!-- Game Board -->
        <div id="board" class="board border-4 border-gray-200 rounded-xl">
            <!-- Cells generated by JavaScript -->
        </div>

    </div>

    <!-- Victory/Restart Modal -->
    <div id="restartModal" class="modal">
        <div class="modal-content">
            <div class="modal-title text-green-600">Game Over!</div>
            <p id="modalMessage" class="modal-message">Player X has won the game!</p>
            <button id="restartButton" onclick="restartGame()"
                class="w-full py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150 ease-in-out shadow-lg transform hover:scale-[1.02] active:scale-[0.98]">
                Restart Game
            </button>
        </div>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const modalElement = document.getElementById('restartModal');
        const modalMessageElement = document.getElementById('modalMessage');

        // Game State
        let board = [
            ['', '', ''],
            ['', '', ''],
            ['', '', '']
        ];
        let currentPlayer = 'X'; // Human is 'X'
        let cpuPlayer = 'O';    // CPU is 'O'
        let isGameOver = false;
        let isCpuThinking = false;

        // --- Core Game Functions ---

        /** Renders the initial 3x3 grid cells and attaches event listeners. */
        function initializeBoard() {
            boardElement.innerHTML = ''; 
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    boardElement.appendChild(cell);
                }
            }
            updateStatus();
        }

        /**
         * Handles a click on a specific cell by the Human player ('X').
         * @param {number} row - The row index (0-2).
         * @param {number} col - The column index (0-2).
         */
        function handleCellClick(row, col) {
            // Only allow human move if it's the human's turn and the CPU isn't thinking
            if (isGameOver || board[row][col] !== '' || currentPlayer === cpuPlayer || isCpuThinking) {
                return; 
            }

            makeMove(row, col, currentPlayer);
            
            // Check state after human move
            if (checkEndGame()) return;

            // Switch to CPU turn
            currentPlayer = cpuPlayer;
            updateStatus();
            
            // Trigger CPU move
            isCpuThinking = true;
            setTimeout(cpuMove, 750); // Add a short delay for better UX
        }

        /**
         * Executes a move on the board for a given player.
         * @param {number} row - Row index.
         * @param {number} col - Column index.
         * @param {string} player - 'X' or 'O'.
         */
        function makeMove(row, col, player) {
            board[row][col] = player;
            
            // Update the UI only if the cell exists (it won't exist during minimax simulation)
            const cellElement = boardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cellElement) {
                cellElement.textContent = player;
                cellElement.classList.add(player === 'X' ? 'x-player' : 'o-player');
            }
        }

        /** Checks for winner/draw and shows the modal if the game ends. */
        function checkEndGame() {
            const winner = checkWinner(board);

            if (winner) {
                isGameOver = true;
                showRestartModal(winner === 'X' ? 'You Win!' : 'CPU Wins!');
                return true;
            } else if (checkDraw(board)) {
                isGameOver = true;
                showRestartModal('It\'s a Draw!');
                return true;
            }
            return false;
        }

        /**
         * Checks if the current board state has a winner.
         * @param {Array<Array<string>>} currentBoard - The board state to check.
         * @returns {string | null} The winning player ('X' or 'O'), or null.
         */
        function checkWinner(currentBoard) {
            const lines = [
                // Rows
                [[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]],
                // Columns
                [[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]],
                // Diagonals
                [[0, 0], [1, 1], [2, 2]], [[0, 2], [1, 1], [2, 0]]
            ];

            for (const line of lines) {
                const [a, b, c] = line;
                const valA = currentBoard[a[0]][a[1]];
                
                if (valA !== '' && valA === currentBoard[b[0]][b[1]] && valA === currentBoard[c[0]][c[1]]) {
                    return valA; // Return the winning player
                }
            }
            return null;
        }

        /**
         * Checks if the game has ended in a draw.
         * @param {Array<Array<string>>} currentBoard - The board state to check.
         * @returns {boolean} True if the board is full and no winner.
         */
        function checkDraw(currentBoard) {
            return currentBoard.every(row => row.every(cell => cell !== ''));
        }

        /** Updates the text showing the current player's turn or game status. */
        function updateStatus() {
            if (isGameOver) {
                statusElement.textContent = 'Game Over!';
            } else if (currentPlayer === cpuPlayer) {
                statusElement.innerHTML = `CPU's Turn: <span class="text-blue-500 font-extrabold">O</span> is thinking...`;
            } else {
                statusElement.innerHTML = `Your Turn: <span class="text-red-500 font-extrabold">X</span>`;
            }
        }

        // --- CPU Logic (Minimax Algorithm) ---

        /** Gets all empty cells as available moves. */
        function getAvailableMoves(currentBoard) {
            let moves = [];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (currentBoard[i][j] === '') {
                        moves.push({ row: i, col: j });
                    }
                }
            }
            return moves;
        }

        /** * The Minimax function is the core of the unbeatable AI.
         * It recursively explores the game tree to find the optimal move.
         * @param {Array<Array<string>>} currentBoard - The board state.
         * @param {string} player - The current player ('X' or 'O').
         * @returns {number} The score (10 for win, -10 for loss, 0 for draw).
         */
        function minimax(currentBoard, player) {
            const winner = checkWinner(currentBoard);
            
            // Base Cases (Terminal states)
            if (winner === cpuPlayer) return 10;
            if (winner === 'X') return -10;
            if (checkDraw(currentBoard)) return 0;

            const moves = getAvailableMoves(currentBoard);

            if (player === cpuPlayer) { // Maximizer (CPU)
                let bestScore = -Infinity;
                for (let i = 0; i < moves.length; i++) {
                    const { row, col } = moves[i];
                    currentBoard[row][col] = player;
                    let score = minimax(currentBoard, 'X');
                    currentBoard[row][col] = ''; // Undo move
                    bestScore = Math.max(score, bestScore);
                }
                return bestScore;
            } else { // Minimizer (Human)
                let bestScore = Infinity;
                for (let i = 0; i < moves.length; i++) {
                    const { row, col } = moves[i];
                    currentBoard[row][col] = player;
                    let score = minimax(currentBoard, cpuPlayer);
                    currentBoard[row][col] = ''; // Undo move
                    bestScore = Math.min(score, bestScore);
                }
                return bestScore;
            }
        }

        /** Finds the optimal move for the CPU using the minimax algorithm. */
        function getBestMove() {
            let bestScore = -Infinity;
            let move = null;
            const availableMoves = getAvailableMoves(board);

            for (let i = 0; i < availableMoves.length; i++) {
                const { row, col } = availableMoves[i];
                
                // 1. Make the move
                board[row][col] = cpuPlayer;
                
                // 2. Calculate the score of this move
                let score = minimax(board, 'X');
                
                // 3. Undo the move
                board[row][col] = ''; 

                // 4. Update the best score and move
                if (score > bestScore) {
                    bestScore = score;
                    move = { row, col };
                }
            }
            return move;
        }

        /** Executes the CPU's turn. */
        function cpuMove() {
            if (isGameOver) return;
            
            const bestMove = getBestMove();
            
            if (bestMove) {
                makeMove(bestMove.row, bestMove.col, cpuPlayer);
                
                isCpuThinking = false;
                
                // Check state after CPU move
                if (checkEndGame()) return;

                // Switch back to Human turn
                currentPlayer = 'X';
                updateStatus();
            }
        }

        // --- Modal and Restart Functions ---

        /**
         * Displays the restart modal with the given message.
         * @param {string} message - The message to display.
         */
        function showRestartModal(message) {
            modalMessageElement.textContent = message;
            modalElement.style.display = 'block';
            
            // Set modal title color based on outcome
            const titleElement = modalElement.querySelector('.modal-title');
            if (message.includes('Win')) {
                titleElement.textContent = 'Congratulations!';
                titleElement.classList.remove('text-red-600');
                titleElement.classList.add('text-green-600');
            } else if (message.includes('CPU Wins')) {
                titleElement.textContent = 'You Lost!';
                titleElement.classList.remove('text-green-600');
                titleElement.classList.add('text-red-600');
            } else {
                titleElement.textContent = 'Game Over!';
                titleElement.classList.remove('text-green-600', 'text-red-600');
                titleElement.classList.add('text-gray-600');
            }
        }

        /** Resets the game state and hides the modal. */
        function restartGame() {
            // Reset game state
            board = [
                ['', '', ''],
                ['', '', ''],
                ['', '', '']
            ];
            currentPlayer = 'X';
            isGameOver = false;
            isCpuThinking = false;

            // Reset UI
            initializeBoard(); 
            modalElement.style.display = 'none';
        }

        // Initialize the game
        initializeBoard();

    </script>
</body>
</html>